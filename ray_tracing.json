{"camera":{"position":[-0.7526280201102187,0.9338150942084988,4.156505718399263],"target":[-0.326,0.647,1],"nearClipping":0.1,"farClipping":1000,"projection":"Perspective","perspectiveFov":45,"orthographicFov":30},"model":{"mesh":"teapot","position":[0,-8,0],"rotationAxis":[1,0,0],"rotationAngle":-90,"scale":[1,1,1],"depthTest":"LESS","faceCulling":"","frontFace":"CCW","blendEnable":true,"blendOperation":"FUNC_ADD","srcColorBlendFactor":"SRC_ALPHA","dstColorBlendFactor":"ONE_MINUS_SRC_ALPHA","srcAlphaBlendFactor":"SRC_ALPHA","dstAlphaBlendFactor":"ONE_MINUS_SRC_ALPHA","textureFiltering":"LINEAR_MIPMAP_LINEAR","maxAnisotropy":"1"},"passes":{"Model":{"base":{"shaders":{"vertex":{"source":"#version 300 es\n\nin vec4 vertexPosition;\n\n// Everything happens in RT2 Shaders\nvoid main(void)\n{\n  gl_Position = vertexPosition;\n}"},"fragment":{"source":"#version 300 es\n\nprecision highp float;\n\nout vec4 fragColor;\n\n//Everything happens in RT2 Shaders\nvoid main(void)\n{\n  fragColor = vec4(0,0,0,0);\n}"}},"uniforms":{"value":{}}}},"Quad":{"R2T":{"shaders":{"vertex":{"source":"#version 300 es\n\n// Vertex coordinates in object space for the render quad\nin vec3 vertexPosition;\n\nuniform float canvasWidth;\nuniform float canvasHeight;\n\nuniform vec3 cameraPosition;\nuniform mat3 cameraRotation;\n\nuniform vec4 lightPosition;\nuniform bool lightInCamspace;\nuniform mat4 vMatrix;\n\nuniform bool isOrthographicProjection;\nuniform float orthographicFOV;\nuniform float perspectiveFOV;\n\nout vec3 origin;\nout vec3 dir;\nout vec3 lightPositionWorldspace;\n\nvoid main() {\n  float aspectRatio = canvasWidth/canvasHeight;\n  vec3 origin_camSpace, dir_camSpace;\n\n  if (isOrthographicProjection) {\n    origin_camSpace = vec3(vertexPosition.x*orthographicFOV*aspectRatio,\n                           vertexPosition.y*orthographicFOV,\n                           0);\n    dir_camSpace = vec3(0, 0, -1);\n  }\n  else { // perspective projection\n    origin_camSpace = vec3(0);\n    dir_camSpace = vec3(vertexPosition.x*aspectRatio,\n                        vertexPosition.y,\n                        -1.0/tan(radians(perspectiveFOV)));\n  }\n\n  origin = cameraPosition + cameraRotation*origin_camSpace;\n  dir = normalize(cameraRotation*dir_camSpace);\n  lightPositionWorldspace = vec3(\n    lightInCamspace ? inverse(vMatrix) * lightPosition: lightPosition\n  );\n\n  gl_Position = vec4(vertexPosition, 1.0); \n}"},"fragment":{"source":"#version 300 es\n// softshadow\n// monte carlo \n// glass sphere\nprecision highp float;\n\nin vec3 origin;\nin vec3 dir;\nin vec3 lightPositionWorldspace;\n\nuniform bool debugView;\n//new\nuniform int SHADOW_SAMPLES;\nuniform int MC_SAMPLES;\nconst int MAX_ENTRIES = 4;\nconst vec3 lightIntensity=vec3(0.8,0.7,0.7); \nconst float lightFlux=10.0; \n//\nout vec4 fragColor;\n\n// Useful constants \nconst float CONST_PI = 3.14159265359;\nconst float CONST_INVPI = 0.318309886184;\n// Useful for controlling light intensity on a global level\nconst float CONST_LIGHT_INTENSITY = 32.0;\n// Some floating point constants to help with the math\n// Only valid in `highp` mode as the values differ in other precisions\n// ref: https://registry.khronos.org/OpenGL/specs/es/2.0/GLSL_ES_Specification_1.00.pdf\nconst float CONST_EPSILON = 1e-6;\nconst float CONST_INF = 4.6116860184e18;\nconst float CONST_RAY_EPSILON = 10.0*CONST_EPSILON;\nconst float CONST_SHADOW_EPSILON = 10.0*CONST_RAY_EPSILON;\nconst float CONST_MAX_RAY_DIST = 0.1*CONST_INF;\nconst int raytraceDepth = 42;\nconst int numSpheres = 2;\nconst int numBoxes = 9;\nconst int numMaterials = 6;\n\nstruct Material {\n    vec3 albedo;\n    vec3 specular;\n    vec3 ior; // Index of Refraction relative to air for the R, G and B channels\n    float roughness;\n    bool metallic;\n};\n\nstruct Ray\n{\n  vec3 origin;\n  vec3 dir;\n};\n\nstruct Sphere\n{\n  vec3 centre;\n  float radius;\n  int material_index;\n};\n\nstruct Plane\n{\n  vec3 point;\n  vec3 normal;\n  int material_index;\n};\n\nstruct Box\n{\n  vec3 origin;\n  vec3 scale;\n  vec4 rotation; // Packed, 3-axis + 1-angle\n  int material_index;\n};\n\nstruct Intersection\n{\n  float t;\n  vec3 point;     // hit point\n  vec3 normal;    // normal\n  vec3 texture_colour;\n  int material_index;\n};\n\nSphere sphere[numSpheres];\nBox box[numBoxes];\nPlane plane;\nMaterial mats[numMaterials];\n\nvec3 rodrigues_rotation(vec3 p, vec3 axis, float angle) {\n    // Applies a rotation to a vector p about axis\n    // using Rodrigues Rotation Formula\n    // ref: https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula\n    if (angle == 0.0) {\n        return p;\n    }\n    float cos_angle = cos(angle);\n    vec3 naxis = normalize(axis);\n    return p*cos_angle + cross(naxis, p)*sin(angle) + naxis*dot(naxis, p)*(1.0 - cos_angle);\n}\n\nfloat rcp(float v) {\n    // safe reciprocal function to avoid issues of NaN/inf\n    // due to 1/0 values\n    return abs(v) > 0.0 ? 1.0/v : CONST_MAX_RAY_DIST;\n}\n\n\nvec3 fresnel_reflectance_normal_incidence(vec3 ior) {\n    // Computes reflectance at normal incidence\n    // given the relative index of refraction of a material\n    return pow((ior - 1.0)/(ior + 1.0), vec3(2.0));\n}\n\nvec3 fresnel_schlick(vec3 F0, float ndotV) {\n    // Schlick's Approximation for fresnel reflections\n    return F0 + (1.0 - F0) * pow(clamp(1.0 - ndotV, 0.0, 1.0), 5.0);\n}\n\nvec3 computeMaterialInteraction(Material mat, vec3 wi, vec3 wo, vec3 normal) {\n    // Implements a microfact BRDF model splitting the reflection into \n    // diffuse and specular components with\n    // D being the distribution function of the microfacetsre\n    // G being the geoemtry term accounting for self-shadowing of microfacets\n    // and F being the fresnel term\n    // ref: https://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n    // incoming ray direction\n    vec3 lightDir = wi;\n    // outgoing ray direction\n    vec3 viewDir = wo;\n    // half-vector for lighting calculations\n    vec3 halfDir = normalize(viewDir + lightDir);\n    // useful dot products\n    float ndotL = dot(lightDir, normal);\n    float ndotH = dot(halfDir, normal);\n    float ndotV = dot(viewDir, normal);\n    float VdotH = dot(halfDir, viewDir);\n    // relation between roughness and alpha used in the angle-based attenuation model\n    float inv_alpha_sqr = rcp(pow(mat.roughness, 4.0));\n    // CHANGE THESE TO CONTROL THE VARIOUS DIFFERENCE REFLECTANCE MODELS\n    // distribution function, currently blinn-phong model\n    float D = pow(ndotH, 2.0*inv_alpha_sqr - 2.0) * CONST_INVPI * inv_alpha_sqr;\n    // geometry term, accounting for self-shadowing\n    float G = ndotL * ndotV;\n    // fresnel term, accounts for change in reflectance at grazing angles\n    vec3 F = fresnel_schlick(mix(fresnel_reflectance_normal_incidence(mat.ior), mat.albedo, float(mat.metallic)), max(ndotV, 0.0));\n    // Put the remaining energy after specular reflection into the diffuse component\n    // If the material is metallic, then there is no diffuse component\n    vec3 kD = (1.0 - F) * (1.0 - float(mat.metallic));\n\n    // Lambertian diffuse model, can be changed to other models as well\n    vec3 diffuse = kD * CONST_INVPI;\n    // END OF CHANGE THESE\n\n    // DO NOT CHANGE FROM HERE\n    // Product of the 3 terms, D, G and F with the normalisation factor\n    vec3 specular = max(D*G*F*rcp(4.0 * max(ndotL, 0.0) * max(ndotV, 0.0)), 0.0);\n\n    // clamped output (to prevent values >1 or <0) combining diffuse and specular components\n    return clamp(vec3(ndotL) * (mat.albedo * diffuse + mat.specular * specular), 0.0, 1.0);\n    // END OF DO NOT CHANGE\n}\n\n\nfloat random(vec3 co) {\n  return fract(sin(dot(co, vec3(12.9898, 78.233, 234.232))) * 43758.5453);\n}\n\n\nvoid sphere_intersect(Sphere sph, Ray ray, inout Intersection intersect)\n{\n  ///////////////////////////////////////////\n  // START OF YOUR CODE\n  ///////////////////////////////////////////\n    // Compute vector from ray origin to sphere center\n    vec3 delta_p = ray.origin - sph.centre;\n    // μ^2 + 2(d · Δp) μ + |Δp|^2 - r^2 = 0\n    float a = 1.0;\n    float b = 2.0 * dot(ray.dir, delta_p);\n    float c = dot(delta_p, delta_p) - sph.radius * sph.radius;\n    // deter = b^2-4ac\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0) {\n      return;\n    }\n    float sqrtDiscriminant = sqrt(discriminant);\n    // Find the two possible solutions\n    float t_0 = (-b - sqrtDiscriminant) / (2.0 * a);\n    float t_1 = (-b + sqrtDiscriminant) / (2.0 * a);\n\n    float t_hit = CONST_INF;\n    if (t_0 > CONST_RAY_EPSILON && t_0 < t_hit) {\n      t_hit = t_0;\n    }\n    if (t_1 > CONST_RAY_EPSILON && t_1 < t_hit) {\n      t_hit = t_1;\n    }\n    if (t_hit < CONST_INF && t_hit < intersect.t ) {\n      intersect.t = t_hit;\n      intersect.point = ray.origin + ray.dir * t_hit;\n      intersect.normal = normalize(intersect.point - sph.centre);\n      intersect.material_index = sph.material_index;\n    }\n  ///////////////////////////////////////////\n  // END OF YOUR CODE\n  ///////////////////////////////////////////\n}\n\nvoid box_intersect(Box bx, Ray ray, inout Intersection intersect)\n{\n  ///////////////////////////////////////////\n  // START OF YOUR CODE\n  ///////////////////////////////////////////\n    // bring ray to box's local space\n    vec3 localOrigin = rodrigues_rotation(ray.origin - bx.origin, bx.rotation.xyz, -bx.rotation.w);\n    vec3 localDir = normalize(rodrigues_rotation(ray.dir, bx.rotation.xyz, -bx.rotation.w));\n    // bound of box\n    vec3 halfSize = bx.scale / 2.0 ;\n    // cloest intersextion\n    float tmin = - CONST_INF;\n    float tmax = CONST_INF;  \n    // iterate through each axis\n    for (int i = 0; i< 3; i++){\n      // check parallel with face\n      if (abs(localDir[i])< CONST_EPSILON){\n        if ((localOrigin[i]< -halfSize[i])||(localOrigin[i] > halfSize[i])){\n          return; \n        }\n      }\n      else {\n        // local ray intersection :localOrigin[i]+t×localDir[i]=−halfSize[i]\n        float t0 = (-halfSize[i]-localOrigin[i]) / localDir[i];\n        // localOrigin[i]+t×localDir[i]=halfSize[i]\n        float t1 = (halfSize[i]-localOrigin[i]) / localDir[i];\n        if (t1< t0){\n          float temp = t0;\n          t0 = t1;\n          t1 = temp;\n        }\n        tmax = min (t1, tmax);\n        tmin = max (t0, tmin);\n        if (tmin> tmax) // case when ray doesn't exist in three slabs\n          return; \n      }\n    }\n    // check epsilon        \n    if (tmin < CONST_RAY_EPSILON) {\n        if (tmax < CONST_RAY_EPSILON)\n          return;\n        tmin = tmax;\n    }\n    float t_hit = tmin;\n    // hit point check\n    vec3 localHitPoint = localOrigin + localDir * t_hit;\n    vec3 localNormal = vec3(0.0);\n    vec3 d = abs(localHitPoint) - halfSize;\n    if(d.x > d.y && d.x > d.z)\n        localNormal = vec3(sign(localHitPoint.x), 0.0, 0.0);\n    else if(d.y > d.z)\n        localNormal = vec3(0.0, sign(localHitPoint.y), 0.0);\n    else\n        localNormal = vec3(0.0, 0.0, sign(localHitPoint.z));\n\n    // back to world space\n    vec3 hitPoint = bx.origin + rodrigues_rotation(localHitPoint, bx.rotation.xyz, bx.rotation.w);\n    vec3 worldNormal = normalize(rodrigues_rotation(localNormal, bx.rotation.xyz, bx.rotation.w));\n\n    if (t_hit < intersect.t) {\n      intersect.t = t_hit;\n      intersect.point = hitPoint;\n      intersect.normal = worldNormal;\n      intersect.material_index = bx.material_index;\n    }\n\n  ///////////////////////////////////////////\n  // END OF YOUR CODE\n  ///////////////////////////////////////////\n}\n\nvoid plane_intersect(Plane pl, Ray ray, inout Intersection intersect)\n{\n  ///////////////////////////////////////////\n  // START OF YOUR CODE\n  ///////////////////////////////////////////\n    float denom = dot(ray.dir, pl.normal);\n    \n    // Check if the ray is parallel to the plane (denom is near zero)\n    if (abs(denom) < CONST_EPSILON) {\n      return;\n    }\n    \n    // Standard formula: t = dot(pl.point - ray.origin, pl.normal) / dot(ray.dir, pl.normal)\n    float t = dot(pl.point - ray.origin, pl.normal) / denom;\n    \n    // If the intersection is behind the ray origin or too close, ignore it\n    if (t < CONST_RAY_EPSILON) {\n      return;\n    }\n    \n    // Fill the intersection structure\n    intersect.t = t;\n    intersect.point = ray.origin + ray.dir * t;\n    intersect.normal = pl.normal;\n    intersect.material_index = pl.material_index;\n    \n    // checkerboard pattern by varying the texture colour\n    // Use the x and z coordinates of the intersection point to determine the pattern.\n    float frequency = 2.0; // Adjust this value to control the number of squares\n    // Compute a checker value using floor on scaled coordinates\n    float check = mod(floor(intersect.point.x * frequency) + floor(intersect.point.z * frequency), 2.0);\n    \n    // If check is less than 1, choose one color; otherwise, choose the other.\n    if (check < 1.0) {\n      intersect.texture_colour = vec3(1.0); // white square\n    } else {\n      intersect.texture_colour = vec3(0.0); // black square\n    }\n  ///////////////////////////////////////////\n  // END OF YOUR CODE\n  ///////////////////////////////////////////\n}\n\nvoid Intersect(Ray r, inout Intersection i)\n{\n  ///////////////////////////////////////////\n  // START OF YOUR CODE\n  ///////////////////////////////////////////\n    i.t = CONST_INF;\n    Intersection temp;\n\n    // sphere\n    for (int s = 0; s < numSpheres; s++){\n      temp.t = CONST_INF;\n      sphere_intersect(sphere[s], r, temp);\n      if (temp.t < i.t)\n        i= temp; \n    }\n    // box \n    for (int b = 0; b < numBoxes; b++){\n      temp.t = CONST_INF;\n      box_intersect(box[b], r, temp);\n      if (temp.t < i.t)\n        i= temp; \n    }\n    //plane\n    temp.t = CONST_INF;\n    plane_intersect(plane, r, temp);\n    if (temp.t < i.t)\n      i= temp; \n\n  ///////////////////////////////////////////\n  // END OF YOUR CODE\n  ///////////////////////////////////////////\n}\n\n\nvec3 computeShadow(in Ray incoming_ray, in Intersection intersect)\n{\n    \n  //  area light \"radius\". Adjust this value to control softness.\n  const float AREA_LIGHT_RADIUS = 0.3;\n  \n  float shadowAccum = 0.0;\n  // Offset origin to avoid self-intersections.\n  vec3 offsetOrigin = intersect.point + CONST_SHADOW_EPSILON * intersect.normal * random(intersect.point.xyz);\n  \n  for (int i = 0; i < SHADOW_SAMPLES; i++) {\n    // Generate two random numbers based on the intersection point and sample index.\n    float theta = 2.0 * CONST_PI * random(vec3(intersect.point.xy, float(i))); // Random angle\n    float r = sqrt(random(vec3(intersect.point.xy, float(i) + 1.0))); // Random radius (sqrt for uniform distribution)\n    float rx = r * cos(theta);\n    float rz = r * sin(theta);\n    // Offset the light position by a small amount in the X and Y directions.\n    vec3 lightPosSample = lightPositionWorldspace + vec3(rx, 0.0, rz) * AREA_LIGHT_RADIUS;\n    \n    // Create the shadow ray toward this sample position.\n    Ray shadowRay;\n    shadowRay.origin = offsetOrigin;\n    shadowRay.dir = normalize(lightPosSample - offsetOrigin);\n    \n    // Trace the shadow ray.\n    Intersection shadowHit;\n    shadowHit.t = CONST_INF;\n    Intersect(shadowRay, shadowHit);\n    \n    // Compute the distance to this sampled light position.\n    float distToLight = length(lightPosSample - offsetOrigin);\n    // If an intersection is found before reaching the light, count it as in shadow.\n    if (shadowHit.t < distToLight) {\n      if (mats[shadowHit.material_index].ior.x >= 1.5) {\n        shadowAccum += 0.5; // Treat refractive materials as transparent\n      } else {\n        shadowAccum +=  1.0; // Opaque object blocks light\n      }\n    } else {\n      shadowAccum += 0.0;\n    }\n  }\n  // Average over all shadow samples.\n  float shadowFactor = shadowAccum / float(SHADOW_SAMPLES);\n  return vec3(shadowFactor);\n}\n\n\nvoid RefractiveRay(inout Ray currentRay,Intersection currentIntersect, Material currentMat, inout vec3 throughput, inout Intersection entryArray[MAX_ENTRIES],inout int arraySize){\n  vec3 N = normalize(currentIntersect.normal);\n  bool entering = dot(currentRay.dir, N) < 0.0;\n  vec3 adjustedNormal = entering ? N : -N;\n  float eta = entering ? (1.0 / currentMat.ior.x) : currentMat.ior.x;\n\n  // Compute reflection and refraction directions\n  vec3 reflectDir = reflect(currentRay.dir, adjustedNormal);\n  vec3 refractDir = refract(currentRay.dir, adjustedNormal, eta);\n  float cosTheta = dot(-currentRay.dir, adjustedNormal);\n  vec3 F0 = fresnel_reflectance_normal_incidence(currentMat.ior);\n  vec3 F = fresnel_schlick(F0, cosTheta);\n\n  if (entering) {\n    // Entering the material: refract and push to Array\n    currentRay.dir = normalize(refractDir);\n    throughput *= (vec3(1.0) - F); // Transmission coefficient\n    if (arraySize < MAX_ENTRIES) {\n      entryArray[arraySize] = currentIntersect;\n      arraySize++;\n    } else {\n      // Array overflow: terminate ray\n      throughput = vec3(0.0);\n      return;\n    }\n    currentRay.origin = currentIntersect.point - N * CONST_RAY_EPSILON;\n  } else {\n    // Exiting the material\n    if (length(refractDir) < CONST_EPSILON) {\n      // Total internal reflection\n      currentRay.dir = normalize(reflectDir);\n      throughput *= F;\n    } else {\n      // Refract out and apply absorption\n      currentRay.dir = normalize(refractDir);\n      throughput *= (vec3(1.0) - F);\n      if (arraySize > 0) {\n        arraySize--;\n        Intersection entryIsect = entryArray[arraySize];\n        float distance = length(currentIntersect.point - entryIsect.point);\n        vec3 absorption = exp(-vec3(0.15) * distance); // Absorption coefficient\n        throughput *= absorption;\n      }\n    }\n    currentRay.origin = currentIntersect.point + N * CONST_RAY_EPSILON;\n  }\n}\n\n\n\nvoid main()\n{\n  //please leave the scene config unaltered for marking reasons\n  mats[0].albedo = vec3(0.8);\n  mats[0].specular = vec3(0.8);\n  mats[0].roughness = 0.3162277660;\n  mats[0].ior = vec3(1.4260);\n  mats[0].metallic = false;\n\n  mats[1].albedo = vec3(0.1,0.1,0.5);\n  mats[1].specular = vec3(0.8);\n  mats[1].roughness = 0.3162277660;\n  mats[1].ior = vec3(1.4260);\n  mats[1].metallic = false;\n\n  mats[2].albedo = vec3(0.5,0.0,0.0);\n  mats[2].specular = vec3(0.8);\n  mats[2].roughness = 0.8944271910;\n  mats[2].ior = vec3(1.4260);\n  mats[2].metallic = false;\n\n  mats[3].albedo = vec3(0.0,0.5,0.0);\n  mats[3].specular = vec3(0.8);\n  mats[3].roughness = 0.8944271910;\n  mats[3].ior = vec3(1.4260);\n  mats[3].metallic = false;\n\n  mats[4].albedo = vec3(1.0);\n  mats[4].specular = vec3(1.0);\n  mats[4].roughness = 0.8944271910;\n  mats[4].ior = vec3(1.4260);\n  mats[4].metallic = false;\n\n  // Glass-like material:\n  mats[5].albedo = vec3(0.0);       \n  mats[5].specular = vec3(1.0);     \n  mats[5].roughness = 0.0;        \n  mats[5].ior = vec3(1.5);         \n  mats[5].metallic = false;\n\n  sphere[0].centre = vec3(-0.75, 0.0, -1.25);\n  sphere[0].radius = 0.5;\n  sphere[0].material_index = 1;\n  sphere[1].centre = vec3(1.0, 0.75, -1.0);\n  sphere[1].radius = 0.5;\n  sphere[1].material_index = 5;\n  // Back Wall\n  box[0].origin = vec3(0.0, 2.5, -6.0);\n  box[0].scale = vec3(6.0, 6.0, 0.1);\n  box[0].material_index = 0;\n  box[0].rotation = vec4(0.0, 1.0, 0.0, CONST_PI*0.0/180.0);\n  // Left Wall\n  box[1].origin = vec3(-3.0, 2.5, -3.0);\n  box[1].scale = vec3(6.0, 6.0, 0.1);\n  box[1].material_index = 2;\n  box[1].rotation = vec4(0.0, 1.0, 0.0, CONST_PI*90.0/180.0);\n  // Right Wall\n  box[2].origin = vec3(3.0, 2.5, -3.0);\n  box[2].scale = vec3(6.0, 6.0, 0.1);\n  box[2].material_index = 3;\n  box[2].rotation = vec4(0.0, 1.0, 0.0, CONST_PI*90.0/180.0);\n  // Ceiling\n  box[3].origin = vec3(3.0-1.0, 5.5, -3.0);\n  box[3].scale = vec3(2.0, 6.0, 0.1);\n  box[3].material_index = 0;\n  box[3].rotation = vec4(1.0, 0.0, 0.0, CONST_PI*90.0/180.0);\n  box[4].origin = vec3(-3.0+1.0, 5.5, -3.0);\n  box[4].scale = vec3(2.0, 6.0, 0.1);\n  box[4].material_index = 0;\n  box[4].rotation = vec4(1.0, 0.0, 0.0, CONST_PI*90.0/180.0);\n  box[5].origin = vec3(0.0, 5.5, -3.0-2.0);\n  box[5].scale = vec3(6.0, 2.0, 0.1);\n  box[5].material_index = 0;\n  box[5].rotation = vec4(1.0, 0.0, 0.0, CONST_PI*90.0/180.0);\n  box[6].origin = vec3(0.0, 5.5, -3.0+2.0);\n  box[6].scale = vec3(6.0, 2.0, 0.1);\n  box[6].material_index = 0;\n  box[6].rotation = vec4(1.0, 0.0, 0.0, CONST_PI*90.0/180.0);\n  // ---- //\n  // Large Box\n  box[7].origin = vec3(-1.0, 1.0, -3.25);\n  box[7].scale = vec3(1.75, 3.0, 1.75);\n  box[7].material_index = 4;\n  box[7].rotation = vec4(0.0, 1.0, 0.0, CONST_PI*20.0/180.0);\n  // Small Box\n  // box[8].origin = vec3(1.0, 0.0, -1.0);\n  // box[8].scale = vec3(1.0, 1.0, 1.0);\n  // box[8].material_index = 0;\n  // box[8].rotation = vec4(0.0, 1.0, 0.0, -CONST_PI*10.0/180.0);\n  plane.point = vec3(0,-0.5, 0);\n  plane.normal = vec3(0, 1.0, 0);\n  plane.material_index = 0;\n  //scene definition end\n\n  ///////////////////////////////////////////\n  // START OF YOUR CODE\n  ///////////////////////////////////////////\n  vec3 colour = vec3(0.0);\n  Intersection entryArray[MAX_ENTRIES];\n  int arraySize = 0;\n  \n  for (int s = 0; s < MC_SAMPLES; s++) {\n    Ray currentRay;\n    // Apply jitter to the primary ray origin.\n    float jitterX = random(vec3(gl_FragCoord.xy, float(s)));\n    float jitterY = random(vec3(gl_FragCoord.xy, float(s) + 1.0));\n    // Small offset for anti-aliasing jitter (tweak 0.001 as desired)\n    currentRay.origin = origin + vec3(jitterX, jitterY, 0.0) * 0.001;\n    // Optionally, you can also jitter the direction.\n    currentRay.dir = normalize(dir + vec3(jitterX, jitterY, 0.0) * 0.001);\n\n    vec3 throughput = vec3(1.0);\n    vec3 sampleColor = vec3(0.0);\n    // Add a very low ambient term if desired.\n    sampleColor += vec3(0.1) / 1000.0;\n\n    const int MAX_DEPTH = 42;\n    for (int bounce = 0; bounce < MAX_DEPTH; bounce++) {\n      Intersection currentIntersect;\n      currentIntersect.t = CONST_INF;\n      Intersect(currentRay, currentIntersect);\n      if (currentIntersect.t == CONST_INF)\n        break;\n\n      Material currentMat = mats[currentIntersect.material_index];\n      vec3 normal = normalize(currentIntersect.normal);\n      vec3 incoming = normalize(lightPositionWorldspace - currentIntersect.point);\n      vec3 outgoing = normalize(-currentRay.dir);\n      vec3 brdfColor = computeMaterialInteraction(currentMat, incoming, outgoing, normal);\n      // Use checkerboard pattern for the ground.\n      if (abs(currentIntersect.point.y + 0.5) < 0.01)\n        brdfColor = currentIntersect.texture_colour;\n\n      float distanceToLight = length(lightPositionWorldspace - currentIntersect.point);\n      float attenuation = lightFlux / (4.0 * CONST_PI * distanceToLight * distanceToLight);\n      vec3 inLight = vec3(1.0)-computeShadow(currentRay, currentIntersect);\n      bool Refractive = currentMat.ior.x >= 1.5;\n      vec3 localColor = vec3(0.0);\n      localColor = inLight * (brdfColor * lightIntensity * attenuation);\n      sampleColor += throughput * localColor;\n\n      if (Refractive) {\n        RefractiveRay(currentRay, currentIntersect, currentMat, throughput,entryArray, arraySize);\n        \n      }else{\n        // Reflective branch only (no refraction):\n        bool reflective = (currentMat.roughness < 0.9);\n        if (reflective) {\n          float ndotV = max(dot(-currentRay.dir, normal), 0.0);\n          vec3 fresnel = fresnel_schlick(mix(fresnel_reflectance_normal_incidence(currentMat.ior), currentMat.albedo,  1.0 - float(currentMat.roughness)), max(ndotV, 0.0));\n          throughput *= fresnel;\n          // Offset to avoid self-intersection; using a random multiplier for extra jitter.\n          vec3 offsetOrigin = currentIntersect.point + CONST_RAY_EPSILON * normal * random(currentIntersect.point.xyz);\n          vec3 reflectedDir = reflect(currentRay.dir, normal);\n          currentRay.origin = offsetOrigin;\n          currentRay.dir = normalize(reflectedDir);\n        } else {\n          break;\n        }\n      }\n    }\n    colour += sampleColor;\n  }\n  colour /= float(MC_SAMPLES);\n  ///////////////////////////////////////////\n  // END OF YOUR CODE\n  ///////////////////////////////////////////\n  // Don't modify below!\n  // Gamma corrected output of values without HDR tonemapping\n  // If the uniform `debugView` is set, then \n  // the red channel shows inf values\n  // the green channel shows overexposed values\n  // the blue channel shows nan values\n  // useful for debugging the correctness of the implementation\n  if (!debugView) {  \n    fragColor.rgb = pow(min(CONST_LIGHT_INTENSITY*colour, vec3(1.0)), vec3(1.0/2.2));\n  } else {\n    fragColor.r = float(isinf(colour.r) || isinf(colour.g) || isinf(colour.b));\n    fragColor.g = float((colour.r > 1e4) || (colour.g > 1e4) || (colour.b > 1e4));\n    fragColor.b = float(isnan(colour.r) || isnan(colour.g) || isnan(colour.b));\n  }\n  fragColor.w = 1.0;\n}"}},"uniforms":{"value":{"canvasWidth":{"attachment":"Canvas Width"},"canvasHeight":{"attachment":"Canvas Height"},"cameraPosition":{"attachment":"Camera Target"},"cameraRotation":{"attachment":"Camera Rotation"},"lightPosition":{"value":[2,2,-2,0]},"lightInCamspace":{"value":[true]},"vMatrix":{"attachment":"View Matrix"},"isOrthographicProjection":{"attachment":"Orthographic Projection?"},"orthographicFOV":{"attachment":"Orthographic FOV"},"perspectiveFOV":{"attachment":"Perspective FOV"},"debugView":{"attachment":"Orthographic Projection?"},"SHADOW_SAMPLES":{"value":[5]},"MC_SAMPLES":{"value":[5]}}}}}},"output":{"image":"Quad/R2T Pass color"}}